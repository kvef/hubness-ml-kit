/**
* Hub Miner: a hubness-aware machine learning experimentation library.
* Copyright (C) 2014  Nenad Tomasev. Email: nenad.tomasev at gmail.com
* 
* This program is free software: you can redistribute it and/or modify it under
* the terms of the GNU General Public License as published by the Free Software
* Foundation, either version 3 of the License, or (at your option) any later
* version.
* 
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along with
* this program. If not, see <http://www.gnu.org/licenses/>.
*/
package gui.synthetic;

import java.awt.Graphics;
import java.awt.Color;
import data.representation.DataSet;
import data.representation.DataInstance;
import java.util.ArrayList;

/**
 * This class represents a panel for drawing synthetic 2D datasets manually.
 *
 * @author Nenad Tomasev <nenad.tomasev at gmail.com>
 */
public class DatasetDrawingPanel extends javax.swing.JPanel {

    // Action constants.
    public static final int INSTANCE_ADD = 0;
    public static final int DATASET_CHANGE = 1;
    public static final int BG_COLOR_CHANGE = 2;
    // There is an undo option here, so we keep track of the history through
    // these variables.
    public ArrayList<DataSet> allDSets = new ArrayList<>(200);
    public ArrayList<Color> prevColors = new ArrayList<>(10);
    public ArrayList<Integer> actionHistory = new ArrayList<>(1000);
    // Different colors for different classes.
    public Color[] classColors;
    // Float values are in the range [0,1], they are re-scaled afterwards.
    public DataSet dset = null;
    public int circlePointRadius = 3;
    public int currClass = 0;
    // Additional variables to support zooming.
    public int startX = 0;
    public int endX = getWidth();
    public int startY = 0;
    public int endY = getHeight();
    // Height and width of the bounding rectangle.
    public int totalHeight = getHeight();
    public int totalWidth = getWidth();

    /**
     * Creates new form DatasetDrawingPanel
     */
    public DatasetDrawingPanel() {
        initComponents();
    }

    /**
     * Undo the last action.
     */
    public void undoLast() {
        if (actionHistory.size() > 0) {
            int lastAction = actionHistory.get(actionHistory.size() - 1);
            actionHistory.remove(actionHistory.size() - 1);
            if (lastAction == INSTANCE_ADD) {
                dset.data.remove(dset.size() - 1);
            } else if (lastAction == BG_COLOR_CHANGE) {
                setBackground(prevColors.get(prevColors.size() - 1));
                prevColors.remove(prevColors.size() - 1);
            } else if (lastAction == DATASET_CHANGE) {
                dset = allDSets.get(allDSets.size() - 1);
                allDSets.remove(allDSets.size() - 1);
            }
            repaint();
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (dset != null) {
            float xChunk = (float) startX / (float) totalWidth;
            float yChunk = (float) startY / (float) totalHeight;
            // Draw the data points.
            for (DataInstance instance : dset.data) {
                int x = (int) ((instance.fAttr[0] - xChunk)
                        * (float) totalWidth * ((float) getWidth()
                        / ((float) endX - (float) startX)));
                int y = (int) ((instance.fAttr[1] - yChunk)
                        * (float) totalHeight * ((float) getHeight()
                        / ((float) endY - (float) startY)));
                g.setColor(classColors[instance.getCategory()]);
                g.fillOval(x - circlePointRadius, y - circlePointRadius,
                        2 * circlePointRadius, 2 * circlePointRadius);
            }
        }
    }

    /**
     * Insert a new data point.
     *
     * @param x Integer that is the X coordinate.
     * @param y Integer that is the Y coordinate.
     */
    public void addAndDrawPoint(int x, int y) {
        if (dset == null) {
            dset = new DataSet();
            dset.fAttrNames = new String[2];
            dset.fAttrNames[0] = "X";
            dset.fAttrNames[1] = "Y";
            dset.data = new ArrayList<>(500);
        }
        Graphics g = getGraphics();
        drawCircle(g, x, y);
        DataInstance instance = new DataInstance(dset);
        float fX = ((float) startX + ((float) x / (float) getWidth())
                * ((float) endX - (float) startX)) / (float) totalWidth;
        instance.fAttr[0] = fX;
        float fY = ((float) startY + ((float) y / (float) getHeight())
                * ((float) endY - (float) startY)) / (float) totalHeight;
        instance.fAttr[1] = fY;
        // Set the category to that of the current class.
        instance.setCategory(currClass);
        dset.addDataInstance(instance);
        repaint();
    }

    /**
     * Inserts a new data point and re-scales while drawing.
     *
     * @param x Integer that is the X coordinate.
     * @param y Integer that is the Y coordinate.
     */
    public void addAndDrawNormalizedPoint(float x, float y) {
        if (dset == null) {
            dset = new DataSet();
            dset.fAttrNames = new String[2];
            dset.fAttrNames[0] = "X";
            dset.fAttrNames[1] = "Y";
            dset.data = new ArrayList<>(500);
        }
        DataInstance instance = new DataInstance(dset);
        instance.fAttr[0] = x;
        instance.fAttr[1] = y;
        Graphics g = getGraphics();
        drawCircle(g, ((int) (x * totalWidth)), ((int) (y * totalHeight)));
        instance.setCategory(currClass);
        dset.addDataInstance(instance);
        repaint();
    }

    /**
     * Draw a circle on top of a Graphics object. The radius is fixed.
     *
     * @param g Graphics object to draw the circle on.
     * @param x Integer that is the X coordinate.
     * @param y Integer that is the Y coordinate.
     */
    private void drawCircle(Graphics g, int x, int y) {
        g.setColor(classColors[currClass]);
        g.fillOval(x - circlePointRadius, y - circlePointRadius,
                2 * circlePointRadius, 2 * circlePointRadius);
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
